'use strict';

var fs = require('fs');
var path = require('path');
var https = require('https');
var http = require('http');

/**
 * Base error class for AlleAI SDK
 */
class AlleAIError extends Error {
    constructor(message, code, status, details) {
        super(message);
        this.code = code;
        this.status = status;
        this.details = details;
        this.name = 'AlleAIError';
    }
}
/**
 * Error for validation failures
 */
class ValidationError extends AlleAIError {
    constructor(message, code = "VALIDATION_ERROR", details) {
        super(message, code, undefined, details);
        this.name = "ValidationError";
    }
}
/**
 * Error for API authentication issues
 */
class AuthenticationError extends AlleAIError {
    constructor(message, code = "AUTH_ERROR", details) {
        super(message, code, 401, details);
        this.name = "AuthenticationError";
    }
}
/**
 * Error for invalid API requests
 */
class InvalidRequestError extends AlleAIError {
    constructor(message, code = "INVALID_REQUEST", details) {
        super(message, code, 400, details);
        this.name = "InvalidRequestError";
    }
}
/**
 * Error for API rate limiting
 */
class RateLimitError extends AlleAIError {
    constructor(message, code = "RATE_LIMIT", details) {
        super(message, code, 429, details);
        this.name = "RateLimitError";
    }
}
/**
 * Error for server/service issues
 */
class ServiceUnavailableError extends AlleAIError {
    constructor(message, code = "SERVICE_ERROR", details) {
        super(message, code, 503, details);
        this.name = "ServiceUnavailableError";
    }
}
/**
 * Error for network/connection issues
 */
class ConnectionError extends AlleAIError {
    constructor(message, code = "CONNECTION_ERROR", details) {
        super(message, code, undefined, details);
        this.name = "ConnectionError";
    }
}
/**
 * Generic API error
 */
class APIError extends AlleAIError {
    constructor(message, code = "API_ERROR", status, details) {
        super(message, code, status, details);
        this.name = "APIError";
    }
}

/**
 * Handles chat-related operations, including generating completions using the AlleAI platform.
 *
 * This class provides methods to interact with the chat API, supporting multi-model completions
 * with various input types like text, audio, images, and more.
 *
 * @class AlleChat
 * @example
 * JavaScript (CommonJS) usage:
 * ```javascript
 * const client = require("alle-ai-sdk");
 * async function runChat() {
 *   const alleai = new client.AlleAIClient({ apiKey: "your-apiKey" });
 *   const chat = await alleai.chat.completion({
 *     models: ["gpt-4o", "yi-large", "gpt-3-5-turbo"],
 *     messages: [
 *       { system: [{ type: "text", text: "You are a helpful assistant." }] },
 *       { user: [{ type: "text", text: "What is photosynthesis?" }] }
 *     ]
 *   });
 *   console.log(chat);
 * }
 * runChat();
 * ```
 * @example
 * TypeScript usage:
 * ```typescript
 * import { AlleAIClient } from "alle-ai-sdk";
 * async function runChat() {
 *   const alleai = new AlleAIClient({ apiKey: "your-apiKey" });
 *   const chat = await alleai.chat.completion({
 *     models: ["gpt-4o", "yi-large", "gpt-3-5-turbo"],
 *     messages: [
 *       { system: [{ type: "text", text: "You are a helpful assistant." }] },
 *       { user: [{ type: "text", text: "What is photosynthesis?" }] }
 *     ]
 *   });
 *   console.log(chat);
 * }
 * runChat();
 * ```
 */
class AlleChat {
    /**
     * Creates an instance of AlleChat with a custom request function.
     *
     * @param {(endpoint: string, body: object) => Promise<any>} makeRequest - The function to make API requests, typically a fetch wrapper.
     */
    constructor(makeRequest) {
        this.makeRequest = makeRequest;
    }
    /**
     * Validates the common parameters used in API requests
     *
     * @param {ApiRequest} request - The request object to validate
     * @throws {ValidationError} If any validation fails
     */
    validateRequestParameters({ models, messages }) {
        // Validate models (required)
        if (!models || !Array.isArray(models) || models.length === 0) {
            throw new ValidationError("models must be a non-empty array of strings");
        }
        if (!models.every((model) => typeof model === "string")) {
            throw new ValidationError("all elements in models must be strings");
        }
        // Validate messages (required)
        if (!messages || !Array.isArray(messages) || messages.length === 0) {
            throw new ValidationError("messages must be a non-empty array");
        }
        messages.forEach((msg, index) => {
            if (!msg || typeof msg !== "object") {
                throw new ValidationError(`messages[${index}] must be an object`);
            }
            const hasValidKey = "system" in msg || "user" in msg || "assistants" in msg;
            if (!hasValidKey) {
                throw new ValidationError(`messages[${index}] must have at least one of: system, user, assistants`);
            }
            this.validateMessageContent(msg, index);
        });
    }
    /**
     * Validates the content of a message object
     *
     * @param {object} msg - The message object to validate
     * @param {number} index - The index of the message in the messages array
     * @throws {ValidationError} If any validation fails
     */
    validateMessageContent(msg, index) {
        // Validate system and user fields
        for (const key of ["system", "user"]) {
            if (key in msg && msg[key]) {
                if (!Array.isArray(msg[key])) {
                    throw new ValidationError(`${key} must be an array of content objects`);
                }
                msg[key].forEach((content, i) => {
                    this.validateContentObject(content, `${key}[${i}]`);
                });
            }
        }
        // Validate assistants field
        if ("assistants" in msg && msg.assistants) {
            if (typeof msg.assistants !== "object" || Array.isArray(msg.assistants)) {
                throw new ValidationError("assistants must be an object mapping models to content arrays");
            }
            Object.values(msg.assistants).forEach((contents, i) => {
                if (!Array.isArray(contents)) {
                    throw new ValidationError(`assistants value at index ${i} must be an array`);
                }
                contents.forEach((content, j) => {
                    this.validateContentObject(content, `assistants value[${j}]`);
                });
            });
        }
    }
    /**
     * Validates a content object
     *
     * @param {any} content - The content object to validate
     * @param {string} path - The path to the content object for error messages
     * @throws {ValidationError} If any validation fails
     */
    validateContentObject(content, path) {
        if (!content || typeof content !== "object" || !("type" in content)) {
            throw new ValidationError(`${path} must be an object with a 'type' property`);
        }
        const validTypes = ["text", "audio_url", "image_url", "video_url"];
        if (!validTypes.includes(content.type)) {
            throw new ValidationError(`${path}.type must be one of: ${validTypes.join(", ")}`);
        }
    }
    /**
     * Generate a chat completion with multiple models.
     *
     * @param {ApiRequest} ApiRequest - Parameters for the chat completion.
     *
     * Required Parameters:
     * @param ApiRequest.models - List of model names (e.g., ["gpt-4", "grok", "gemini"])
     * @param ApiRequest.messages - List of message objects, each with optional keys:
     *    - system: System messages (e.g., [{"type": "text", "text": "You are a helper"}])
     *    - user: User messages (e.g., [{"type": "text", "text": "Hello"}])
     *    - assistants: Assistant responses keyed by model name (e.g., {"grok": [{"type": "text", "text": "Hi"}]})
     * @param ApiRequest.response_format - Desired output format:
     *    - type: "text" | "audio_url" | "image_url" | "video_url"
     *    - model_specific: Optional per-model response types (e.g., {"grok": "text"})
     *
     * Optional Parameters:
     * @param ApiRequest.web_search - Enable web search context (default: false)
     * @param ApiRequest.comparison - Compare with type and models
     * @param ApiRequest.combination - Combinations with type and models
     * @param ApiRequest.temperature - Sampling temperature (0.0 to 2.0, default: 1.0)
     * @param ApiRequest.max_tokens - Maximum tokens in the response
     * @param ApiRequest.frequency_penalty - Penalty for frequent words (-2.0 to 2.0, default: 0.0)
     * @param ApiRequest.presence_penalty - Penalty for repeated topics (-2.0 to 2.0, default: 0.0)
     * @param ApiRequest.stream - Stream the response (default: false)
     *
     * @returns {Promise<any>} API response with results from each model, structured according to response_format
     *
     * @throws {ValidationError} If required parameters are missing or invalid
     *
     * @example
     * CommonJS usage:
     * ```javascript
     * const { AlleAIClient } = require("alle-ai-sdk");
     *
     * // Initialize client with API key
     * const alleai = new AlleAIClient({ apiKey: process.env.ALLEAI_API_KEY });
     *
     * // Generate chat completion
     * async function runChat() {
     *   const chat = await alleai.chat.completions({
     *     models: ["gpt-4o", "yi-large", "gpt-3-5-turbo"],
     *     messages: [
     *       {
     *         system: [
     *           {
     *             type: "text",
     *             text: "You are a helpful assistant."
     *           }
     *         ]
     *       },
     *       {
     *         user: [
     *           {
     *             type: "text",
     *             text: "tell me about photosynthesis?"
     *           }
     *         ]
     *       }
     *     ],
     *     temperature: 0.7,
     *     max_tokens: 2000,
     *     frequency_penalty: 0.2,
     *     presence_penalty: 0.3,
     *     stream: false
     *   });
     *
     *   console.log(chat);
     * }
     *
     * runChat();
     * ```
     *
     * @example
     * TypeScript usage:
     * ```typescript
     * import { AlleAIClient } from "alle-ai-sdk";
     *
     * // Initialize client with API key
     * const alleai = new AlleAIClient({ apiKey: process.env.ALLEAI_API_KEY });
     *
     * // Generate chat completion
     * async function runChat() {
     *   const chat = await alleai.chat.completions({
     *     models: ["gpt-4o", "yi-large", "gpt-3-5-turbo"],
     *     messages: [
     *       {
     *         system: [
     *           {
     *             type: "text",
     *             text: "You are a helpful assistant."
     *           }
     *         ]
     *       },
     *       {
     *         user: [
     *           {
     *             type: "text",
     *             text: "tell me about photosynthesis?"
     *           }
     *         ]
     *       }
     *     ],
     *     temperature: 0.7,
     *     max_tokens: 2000,
     *     frequency_penalty: 0.2,
     *     presence_penalty: 0.3,
     *     stream: false
     *   });
     *
     *   console.log(chat);
     * }
     *
     * runChat();
     * ```
     */
    async completions(request) {
        this.validateRequestParameters(request);
        return this.makeRequest("/chat/completions", request);
    }
    /**
     * Generate a combined output from multiple AI models based on the provided messages.
     *
     * This method shares the same parameter structure as completions(), but specializes in
     * generating unified responses. While completions() returns individual responses from each model,
     * this endpoint synthesizes a single, combined response drawing from all specified models'
     * capabilities and perspectives.
     *
     * @param {ApiRequest} ApiRequest - Parameters for the combination (same structure as completions())
     * @returns {Promise<any>} API response with a combined result, structured according to response_format
     * @throws {ValidationError} If required parameters are missing or invalid
     *
     * @example
     * CommonJS usage:
     * ```javascript
     * const { AlleAIClient } = require("alle-ai-sdk");
     *
     * // Initialize client with API key
     * const alleai = new AlleAIClient({ apiKey: process.env.ALLEAI_API_KEY });
     *
     * // Generate combined output from multiple models
     * async function runCombination() {
     *   const result = await alleai.chat.combination({
     *     models: ["gpt-4o", "llama-3-1-8b-instruct"],
     *     messages: [
     *       {
     *         system: [
     *           {
     *             type: "text",
     *             text: "You are a helpful assistant that provides comprehensive answers."
     *           }
     *         ]
     *       },
     *       {
     *         user: [
     *           {
     *             type: "text",
     *             text: "Compare quantum computing with classical computing"
     *           }
     *         ]
     *       }
     *     ],
     *     temperature: 0.7,
     *     max_tokens: 2000
     *   });
     *
     *   console.log(result);
     * }
     *
     * runCombination();
     * ```
     *
     * @example
     * TypeScript usage:
     * ```typescript
     * import { AlleAIClient } from "alle-ai-sdk";
     *
     * // Initialize client with API key
     * const alleai = new AlleAIClient({ apiKey: process.env.ALLEAI_API_KEY });
     *
     * // Generate combined output from multiple models
     * async function runCombination() {
     *   const result = await alleai.chat.combination({
     *     models: ["gpt-4o", "llama-3-1-8b-instruct"],
     *     messages: [
     *       {
     *         system: [
     *           {
     *             type: "text",
     *             text: "You are a helpful assistant that provides comprehensive answers."
     *           }
     *         ]
     *       },
     *       {
     *         user: [
     *           {
     *             type: "text",
     *             text: "Compare quantum computing with classical computing"
     *           }
     *         ]
     *       }
     *     ],
     *     temperature: 0.7,
     *     max_tokens: 2000
     *   });
     *
     *   console.log(result);
     * }
     *
     * runCombination();
     * ```
     */
    async combination(request) {
        this.validateRequestParameters(request);
        return this.makeRequest("/chat/combination", request);
    }
    /**
     * Generate focused model-to-model comparisons using the AlleAI platform.
     *
     * This method shares the same parameter structure as completions(), but serves a distinct purpose:
     * while completions() can return both individual responses and comparisons, comparison() specializes
     * in delivering only the comparative analysis between models. This optimization is valuable when your
     * application needs to analyze differences between model responses without processing individual outputs.
     *
     * @param {ApiRequest} ApiRequest - Standard completion parameters as used in completions(), including:
     *    - models: string[] - Models to compare (e.g., ["gpt-4", "grok"])
     *    - messages: Message[] - The conversation context
     *    - response_format: ResponseFormat - Output format specification
     *    - temperature, max_tokens, etc. - Standard generation parameters
     *
     *    The comparison parameter is required for this endpoint:
     *    - comparison: Comparison[] - Specifies comparison configurations
     *        - type: "text" | "audio_url" | "image_url" | "video_url"
     *        - models: string[] - Models to include in comparison
     *
     * @returns {Promise<any>} A structured comparison response containing:
     *    - Comparative analysis between specified models
     *    - Key differences and similarities in model outputs
     *    - Model-specific insights based on the comparison type
     *
     * @throws {ValidationError} If required parameters are missing or invalid
     *
     * Note:
     * This endpoint is optimized for comparison workflows. For individual model responses
     * alongside comparisons, use the completions() endpoint instead.
     *
     * See completions() method documentation for detailed parameter descriptions and options.
     *
     * @example
     * CommonJS usage:
     * ```javascript
     * const { AlleAIClient } = require("alle-ai-sdk");
     *
     * // Initialize client with API key
     * const alleai = new AlleAIClient({ apiKey: process.env.ALLEAI_API_KEY });
     *
     * // Generate model comparison
     * async function runComparison() {
     *   const comparison = await alleai.chat.comparison({
     *     models: ["gpt-4o-mini", "yi-large"],
     *     messages: [
     *       {
     *         system: [
     *           {
     *             type: "text",
     *             text: "You are a helpful assistant."
     *           }
     *         ]
     *       },
     *       {
     *         user: [
     *           {
     *             type: "text",
     *             text: "Compare the approaches to async programming in Python and JavaScript."
     *           }
     *         ]
     *       }
     *     ],
     *     comparison: [
     *       {
     *         type: "text",
     *         models: ["gpt-4o-mini", "yi-large"]
     *       }
     *     ],
     *     temperature: 0.7,
     *     max_tokens: 2000,
     *     frequency_penalty: 0.2,
     *     presence_penalty: 0.3,
     *     stream: false
     *   });
     *
     *   console.log(comparison);
     * }
     *
     * runComparison();
     * ```
     *
     * @example
     * TypeScript usage:
     * ```typescript
     * import { AlleAIClient } from "alle-ai-sdk";
     *
     * // Initialize client with API key
     * const alleai = new AlleAIClient({ apiKey: process.env.ALLEAI_API_KEY });
     *
     * // Generate model comparison
     * async function runComparison() {
     *   const comparison = await alleai.chat.comparison({
     *     models: ["gpt-4o-mini", "yi-large"],
     *     messages: [
     *       {
     *         system: [
     *           {
     *             type: "text",
     *             text: "You are a helpful assistant."
     *           }
     *         ]
     *       },
     *       {
     *         user: [
     *           {
     *             type: "text",
     *             text: "Compare the approaches to async programming in Python and JavaScript."
     *           }
     *         ]
     *       }
     *     ],
     *     comparison: [
     *       {
     *         type: "text",
     *         models: ["gpt-4o-mini", "yi-large"]
     *       }
     *     ],
     *     temperature: 0.7,
     *     max_tokens: 2000,
     *     frequency_penalty: 0.2,
     *     presence_penalty: 0.3,
     *     stream: false
     *   });
     *
     *   console.log(comparison);
     * }
     *
     * runComparison();
     * ```
     */
    async comparison(request) {
        // this.validateRequestParameters(request);
        return this.makeRequest("/chat/comparison", request);
    }
    /**
     * Generate AI responses enhanced with real-time web search results.
     *
     * This method shares the same parameter structure as completions(), but specializes in
     * web-augmented responses. While completions() can incorporate web search when web_search=True,
     * this dedicated endpoint optimizes for search-enhanced responses. It automatically integrates
     * relevant web information into the model's response without returning separate search results.
     *
     * @param {ApiRequest} ApiRequest - Standard completion parameters as used in completions(), including:
     *    - models: string[] - Models to generate responses (e.g., ["gpt-4", "grok"])
     *    - messages: Message[] - The conversation context
     *    - response_format: ResponseFormat - Output format specification
     *    - temperature, max_tokens, etc. - Standard generation parameters
     *
     *    Note: web_search parameter is automatically set to true for this endpoint
     *
     * @returns {Promise<any>} A structured response containing:
     *    - AI-generated content enriched with web search results
     *    - Seamlessly integrated web information in the response
     *    - Citations and references when applicable
     *
     * @throws {ValidationError} If required parameters are missing or invalid
     *
     * Note:
     * This endpoint is optimized for web-enhanced responses. For separate model responses
     * and web search results, use the completions() endpoint with web_search=true instead.
     *
     * See completions() method documentation for detailed parameter descriptions and options.
     *
     * @example
     * CommonJS usage:
     * ```javascript
     * const { AlleAIClient } = require("alle-ai-sdk");
     *
     * // Initialize client with API key
     * const alleai = new AlleAIClient({ apiKey: process.env.ALLEAI_API_KEY });
     *
     * // Generate web-enhanced response
     * async function runWebSearch() {
     *   const searchResponse = await alleai.chat.search({
     *     models: ["gpt-4o", "gpt-3-5-turbo"],
     *     messages: [
     *       {
     *         system: [
     *           {
     *             type: "text",
     *             text: "You are a helpful assistant with access to current information."
     *           }
     *         ]
     *       },
     *       {
     *         user: [
     *           {
     *             type: "text",
     *             text: "What are the latest developments in quantum computing as of 2024?"
     *           }
     *         ]
     *       }
     *     ],
     *     temperature: 0.7,
     *     max_tokens: 2000,
     *     response_format: { type: "text" }
     *   });
     *
     *   console.log(searchResponse);
     * }
     *
     * runWebSearch();
     * ```
     *
     * @example
     * TypeScript usage:
     * ```typescript
     * import { AlleAIClient } from "alle-ai-sdk";
     *
     * // Initialize client with API key
     * const alleai = new AlleAIClient({ apiKey: process.env.ALLEAI_API_KEY });
     *
     * // Generate web-enhanced response
     * async function runWebSearch() {
     *   const searchResponse = await alleai.chat.search({
     *     models: ["gpt-4o", "gpt-3-5-turbo"],
     *     messages: [
     *       {
     *         system: [
     *           {
     *             type: "text",
     *             text: "You are a helpful assistant with access to current information."
     *           }
     *         ]
     *       },
     *       {
     *         user: [
     *           {
     *             type: "text",
     *             text: "What are the latest developments in quantum computing as of 2024?"
     *           }
     *         ]
     *       }
     *     ],
     *     temperature: 0.7,
     *     max_tokens: 2000,
     *     response_format: { type: "text" }
     *   });
     *
     *   console.log(searchResponse);
     * }
     *
     * runWebSearch();
     * ```
     */
    async search(request) {
        this.validateRequestParameters(request);
        return this.makeRequest("/ai/web-search", request);
    }
}

const MAX_FILE_SIZE = 20 * 1024 * 1024; // 20MB in bytes
// Supported file extensions by type
const SUPPORTED_EXTENSIONS = {
    image: new Set([".jpg", ".jpeg", ".png", ".gif", ".bmp"]),
    audio: new Set([".mp3", ".wav", ".ogg", ".m4a", ".aac"]),
    video: new Set([".mp4", ".mov", ".avi", ".webm"]),
    pdf: new Set([".pdf"])
};
/**
 * Downloads a file from URL and saves it locally
 * @param url URL to download from
 * @param destPath Path to save the file to
 */
async function downloadFile(url, destPath) {
    return new Promise((resolve, reject) => {
        const protocol = url.startsWith('https') ? https : http;
        const fileStream = fs.createWriteStream(destPath);
        protocol.get(url, (response) => {
            if (response.statusCode !== 200) {
                fileStream.close();
                fs.promises.unlink(destPath).catch(() => { }); // Clean up file
                reject(new Error(`Failed to download file: ${response.statusMessage}`));
                return;
            }
            response.pipe(fileStream);
            fileStream.on('finish', () => {
                fileStream.close();
                resolve();
            });
        }).on('error', (err) => {
            fileStream.close();
            fs.promises.unlink(destPath).catch(() => { }); // Clean up file
            reject(err);
        });
    });
}
/**
 * Processes a file path or URL and returns the file buffer and metadata
 * @param filePath Path to local file or URL
 * @param type Type of file to process
 * @returns Promise with buffer and metadata
 */
const processFile = async (filePath, type) => {
    try {
        // Check if it's a URL
        const url = new URL(filePath);
        const fileExt = path.extname(url.pathname).toLowerCase();
        // Validate file extension
        if (!SUPPORTED_EXTENSIONS[type].has(fileExt)) {
            throw new Error(`URL file type '${fileExt}' not supported for ${type}. Supported types: ${Array.from(SUPPORTED_EXTENSIONS[type]).join(", ")}`);
        }
        // Create temp directory if it doesn't exist
        const tempDir = path.join(process.cwd(), 'temp');
        await fs.promises.mkdir(tempDir, { recursive: true });
        // Generate temp file path
        const filename = path.basename(url.pathname);
        const tempPath = path.join(tempDir, `${Date.now()}-${filename}`);
        // Download file
        await downloadFile(url.toString(), tempPath);
        // Get file stats
        const stats = await fs.promises.stat(tempPath);
        if (stats.size > MAX_FILE_SIZE) {
            await fs.promises.unlink(tempPath); // Clean up
            throw new Error(`File size (${(stats.size / 1024 / 1024).toFixed(2)}MB) exceeds max limit (20MB)`);
        }
        // Read the file
        const buffer = await fs.promises.readFile(tempPath);
        // Clean up temp file
        await fs.promises.unlink(tempPath);
        return { buffer, filename, filepath: tempPath };
    }
    catch (e) {
        // Not a URL, process as local file
        if (!(e instanceof TypeError)) {
            throw e; // Rethrow if it's not a URL parsing error
        }
        // Handle local file
        try {
            const absolutePath = path.resolve(process.cwd(), filePath.trim());
            const stats = await fs.promises.stat(absolutePath);
            if (!stats.isFile()) {
                throw new Error(`Not a file: ${filePath}`);
            }
            if (stats.size > MAX_FILE_SIZE) {
                throw new Error(`File size (${(stats.size / 1024 / 1024).toFixed(2)}MB) exceeds max limit (20MB)`);
            }
            const fileExt = path.extname(absolutePath).toLowerCase();
            if (!SUPPORTED_EXTENSIONS[type].has(fileExt)) {
                throw new Error(`File type '${fileExt}' not supported for ${type}. Supported types: ${Array.from(SUPPORTED_EXTENSIONS[type]).join(", ")}`);
            }
            const buffer = await fs.promises.readFile(absolutePath);
            const filename = path.basename(absolutePath);
            return { buffer, filename, filepath: absolutePath };
        }
        catch (error) {
            if (error.code === 'ENOENT') {
                throw new Error(`File not found: ${filePath}`);
            }
            throw error;
        }
    }
};

// Use require for form-data since it's a CommonJS module
const FormData$1 = require('form-data');
/**
 * Handles image-related operations, including generating and editing images.
 * @class AlleImage
 * @example
 * JavaScript (CommonJS) usage:
 * ```javascript
 * const client = require("alle-ai-sdk");
 * async function runImage() {
 *   const alleai = new client.AlleAIClient({ apiKey: "your-apiKey" });
 *   const image = await alleai.image.generate({
 *     models: ["dall-e-3", "grok-2-image"],
 *     prompt: "A beautiful landscape at sunset",
 *     width: 1024,
 *     height: 1024,
 *     n: 1,
 *     style_preset: "digital-art",
 *     model_specific_params: {
 *       // Optional model-specific parameters
 *     }
 *   });
 *   console.log(image);
 * }
 * runImage();
 * ```
 * @example
 * TypeScript usage:
 * ```typescript
 * import { AlleAIClient } from "alle-ai-sdk";
 * async function runImage() {
 *   const alleai = new AlleAIClient({ apiKey: "your-apiKey" });
 *   const image = await alleai.image.generate({
 *     models: ["dall-e-3", "grok-2-image"],
 *     prompt: "A beautiful landscape at sunset",
 *     width: 1024,
 *     height: 1024,
 *     n: 1,
 *     style_preset: "digital-art",
 *     model_specific_params: {
 *       // Optional model-specific parameters
 *     }
 *   });
 *   console.log(image);
 * }
 * runImage();
 * ```
 */
class AlleImage {
    /**
     * Creates an instance of AlleImage.
     * @param {function} makeRequest - The function to make JSON API requests
     * @param {function} makeFormDataRequest - The function to make FormData API requests
     */
    constructor(makeRequest, makeFormDataRequest) {
        this.makeRequest = makeRequest;
        this.makeFormDataRequest = makeFormDataRequest;
    }
    /**
     * Generates images from the provided text prompt using multiple AI models.
     * @param {ImageGenerate} request - The request object containing:
     * - models: Array of model identifiers to use for generation (required)
     * - prompt: Text description of the desired image (required)
     * - width: (optional) Output image width in pixels
     * - height: (optional) Output image height in pixels
     * - n: (optional) Number of images to generate (default: 1)
     * - style_preset: (optional) Art style preset to apply
     * - seed: (optional) Random seed for reproducible results, can be null
     * - model_specific_params: (optional) Additional parameters specific to certain models
     * @returns {Promise<string>} A promise that resolves to the URL of the generated image
     * @throws {ValidationError} Will throw an error if required parameters are missing or invalid
     * @example
     * ```typescript
     * const image = await alleai.image.generate({
     *   models: ["dall-e-3", "grok-2-image"],
     *   prompt: "A beautiful landscape at sunset",
     *   width: 1024,
     *   height: 1024,
     *   n: 1,
     *   style_preset: "digital-art"
     * });
     * ```
     */
    async generate({ models, prompt, width = 1024, height = 1024, n = 1, style_preset = null, seed = null, model_specific_params = {}, }) {
        // Validate required parameters
        if (!models || !Array.isArray(models) || models.length === 0) {
            throw new ValidationError("models must be a non-empty array of strings");
        }
        if (!models.every((model) => typeof model === "string")) {
            throw new ValidationError("all elements in models must be strings");
        }
        if (!prompt || typeof prompt !== "string" || prompt.trim() === "") {
            throw new ValidationError("prompt must be a non-empty string");
        }
        // Validate optional parameters
        if (width !== undefined) {
            if (typeof width !== "number" || !Number.isInteger(width) || width < 64) {
                throw new ValidationError("width must be an integer >= 64");
            }
        }
        if (height !== undefined) {
            if (typeof height !== "number" ||
                !Number.isInteger(height) ||
                height < 64) {
                throw new ValidationError("height must be an integer >= 64");
            }
        }
        if (n !== undefined) {
            if (typeof n !== "number" || !Number.isInteger(n) || n < 1) {
                throw new ValidationError("n must be an integer >= 1");
            }
        }
        if (seed !== null && seed !== undefined) {
            if (typeof seed !== "number" || !Number.isInteger(seed)) {
                throw new ValidationError("seed must be an integer or null");
            }
        }
        if (style_preset !== null && style_preset !== undefined) {
            if (typeof style_preset !== "string") {
                throw new ValidationError("style_preset must be a string or null");
            }
        }
        if (model_specific_params !== undefined) {
            if (typeof model_specific_params !== "object" ||
                model_specific_params === null) {
                throw new ValidationError("model_specific_params must be an object");
            }
        }
        const body = {
            models,
            prompt,
            width,
            height,
            n,
            style_preset,
            seed,
            model_specific_params,
        };
        return await this.makeRequest("/image/generate", body);
    }
    /**
     * Edits an image based on the provided parameters.
     * @param {ImageEdit} request - The request object containing:
     * - models: Array of model identifiers to use for editing (required) - e.g., ["dall-e-3", "titan-image-generator"]
     * - prompt: Description of desired changes (required)
     * - image_file: Path to the image file or URL (required)
     * @returns {Promise<string>} A promise that resolves to the URL of the edited image
     * @throws {ValidationError} Will throw an error if required parameters are missing or invalid
     * @example
     * JavaScript (CommonJS) usage:
     * ```javascript
     * const client = require("alle-ai-sdk");
     * async function runImageEdit() {
     *   const alleai = new client.AlleAIClient({ apiKey: "your-apiKey" });
     *   const editedImage = await alleai.image.edit({
     *     models: ["dall-e-3", "titan-image-generator"],
     *     prompt: "Add a sunset background",
     *     image_file: "./input.jpg"  // or "https://example.com/image.jpg"
     *   });
     *   console.log(editedImage);
     * }
     * runImageEdit();
     * ```
     * @example
     * TypeScript usage:
     * ```typescript
     * import { AlleAIClient } from "alle-ai-sdk";
     * async function runImageEdit() {
     *   const alleai = new AlleAIClient({ apiKey: "your-apiKey" });
     *   const editedImage = await alleai.image.edit({
     *     models: ["dall-e-3", "titan-image-generator"],
     *     prompt: "Add a sunset background",
     *     image_file: "./input.jpg"  // or "https://example.com/image.jpg"
     *   });
     *   console.log(editedImage);
     * }
     * runImageEdit();
     * ```
     */
    async edit({ models, prompt, image_file }) {
        // Validate required parameters
        if (!models || !Array.isArray(models) || models.length === 0) {
            throw new ValidationError("models must be a non-empty array of strings");
        }
        if (!models.every((model) => typeof model === "string")) {
            throw new ValidationError("all elements in models must be strings");
        }
        if (!prompt || typeof prompt !== "string" || prompt.trim() === "") {
            throw new ValidationError("prompt must be a non-empty string");
        }
        if (!image_file ||
            typeof image_file !== "string" ||
            image_file.trim() === "") {
            throw new ValidationError("image_file must be a non-empty string");
        }
        try {
            // Process the image file
            const { buffer, filename } = await processFile(image_file, "image");
            // Create FormData and append fields
            const formData = new FormData$1();
            // Append each model
            models.forEach((model, index) => {
                formData.append(`models[${index}]`, model);
            });
            // Append the buffer directly with filename
            formData.append("image_file", buffer, {
                filename: filename,
            });
            // Add the prompt
            formData.append("prompt", prompt);
            return await this.makeFormDataRequest("/image/edit", formData);
        }
        catch (error) {
            // Enhance error message with more context
            throw new ValidationError(`Failed to process image file: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
}

// Use require for form-data since it's a CommonJS module
const FormData = require('form-data');
/**
 * Handles audio-related operations, including generating audio from text,
 * text-to-speech, and speech-to-text.
 * @class AlleAudio
 * @example
 * JavaScript (CommonJS) usage:
 * ```javascript
 * const client = require("alle-ai-sdk");
 * async function runAudio() {
 *   const alleai = new client.AlleAIClient({ apiKey: "your-apiKey" });
 *   const audio = await alleai.audio.generate({
 *     models: ["lyria"],
 *     prompt: "A soothing jazz melody with soft piano and gentle saxophone",
 *     model_specific_params: {
 *       // Optional model-specific parameters
 *     }
 *   });
 *   console.log(audio);
 * }
 * runAudio();
 * ```
 * @example
 * TypeScript usage:
 * ```typescript
 * import { AlleAI } from "alle-ai-sdk";
 * async function runAudio() {
 *   const alleai = new AlleAIClient({ apiKey: "your-apiKey" });
 *   const audio = await alleai.audio.generate({
 *     models: ["lyria"],
 *     prompt: "A soothing jazz melody with soft piano and gentle saxophone",
 *     model_specific_params: {
 *       // Optional model-specific parameters
 *     }
 *   });
 *   console.log(audio);
 * }
 * runAudio();
 * ```
 */
class AlleAudio {
    /**
     * Creates an instance of AlleAudio.
     * @param {function} makeRequest - The function to make JSON API requests
     * @param {function} makeFormDataRequest - The function to make FormData API requests
     */
    constructor(makeRequest, makeFormDataRequest) {
        this.makeRequest = makeRequest;
        this.makeFormDataRequest = makeFormDataRequest;
    }
    /**
     * Generates audio from the provided text prompt using AI model.
     * @param {audioGenerateTypes} request - The request object containing:
     * - models: Array of model identifiers to use for generation (required) - e.g., ["lyria"]
     * - prompt: Text description of the desired audio (required)
     * - model_specific_params: Additional parameters specific to the model (optional)
     * @returns {Promise<string>} A promise that resolves to the URL of the generated audio
     * @throws {ValidationError} Will throw an error if required parameters are missing or invalid
     * @example
     * JavaScript (CommonJS) usage:
     * ```javascript
     * const client = require("alle-ai-sdk");
     * async function runAudio() {
     *   const alleai = new client.AlleAIClient({ apiKey: "your-apiKey" });
     *   const audio = await alleai.audio.generate({
     *     models: ["lyria"],
     *     prompt: "A soothing jazz melody with soft piano and gentle saxophone",
     *     model_specific_params: {
     *       // Optional model-specific parameters
     *     }
     *   });
     *   console.log(audio);
     * }
     * runAudio();
     * ```
     * @example
     * TypeScript usage:
     * ```typescript
     * import { AlleAI } from "alle-ai-sdk";
     * async function runAudio() {
     *   const alleai = new AlleAIClient({ apiKey: "your-apiKey" });
     *   const audio = await alleai.audio.generate({
     *     models: ["lyria"],
     *     prompt: "A soothing jazz melody with soft piano and gentle saxophone",
     *     model_specific_params: {
     *       // Optional model-specific parameters
     *     }
     *   });
     *   console.log(audio);
     * }
     * runAudio();
     * ```
     */
    async generate({ models, prompt, model_specific_params = {}, }) {
        // Validate required parameters
        if (!models || !Array.isArray(models) || models.length === 0) {
            throw new ValidationError("models must be a non-empty array of strings");
        }
        if (!models.every((model) => typeof model === "string")) {
            throw new ValidationError("all elements in models must be strings");
        }
        if (!prompt || typeof prompt !== "string" || prompt.trim() === "") {
            throw new ValidationError("prompt must be a non-empty string");
        }
        // Simple validation for model_specific_params
        if (model_specific_params !== undefined &&
            typeof model_specific_params !== "object") {
            throw new ValidationError("model_specific_params must be an object");
        }
        return this.makeRequest("/audio/generate", {
            models,
            prompt,
            model_specific_params,
        });
    }
    /**
     * Converts text to speech using AI model.
     * @param {ttsTypes} request - The request object containing:
     * - models: Array of model identifiers to use for text-to-speech (required) - e.g., ["gpt-4o-mini-tts"]
     * - prompt: Text to convert to speech (required)
     * - voice: Voice identifier to use (optional, defaults to "nova")
     * - model_specific_params: Additional parameters specific to the model (optional)
     * @returns {Promise<string>} A promise that resolves to the URL of the generated audio
     * @throws {ValidationError} Will throw an error if required parameters are missing or invalid
     * @example
     * JavaScript (CommonJS) usage:
     * ```javascript
     * const client = require("alle-ai-sdk");
     * async function runTTS() {
     *   const alleai = new client.AlleAIClient({ apiKey: "your-apiKey" });
     *   // With default voice
     *   const audio1 = await alleai.audio.tts({
     *     models: ["gpt-4o-mini-tts"],
     *     prompt: "Welcome to the future of AI technology."
     *   });
     *
     *   // With specific voice
     *   const audio2 = await alleai.audio.tts({
     *     models: ["gpt-4o-mini-tts"],
     *     prompt: "Welcome to the future of AI technology.",
     *     voice: "nova",
     *     model_specific_params: {
     *       // Optional model-specific parameters
     *     }
     *   });
     * }
     * runTTS();
     * ```
     * @example
     * TypeScript usage:
     * ```typescript
     * import { AlleAI } from "alle-ai-sdk";
     * async function runTTS() {
     *   const alleai = new AlleAIClient({ apiKey: "your-apiKey" });
     *   // With default voice
     *   const audio1 = await alleai.audio.tts({
     *     models: ["gpt-4o-mini-tts"],
     *     prompt: "Welcome to the future of AI technology."
     *   });
     *
     *   // With specific voice
     *   const audio2 = await alleai.audio.tts({
     *     models: ["gpt-4o-mini-tts"],
     *     prompt: "Welcome to the future of AI technology.",
     *     voice: "nova",
     *     model_specific_params: {
     *       // Optional model-specific parameters
     *     }
     *   });
     * }
     * runTTS();
     * ```
     */
    async tts({ models, prompt, voice = "nova", model_specific_params = {}, }) {
        // Validate required parameters
        if (!models || !Array.isArray(models) || models.length === 0) {
            throw new ValidationError("models must be a non-empty array of strings");
        }
        if (!models.every((model) => typeof model === "string")) {
            throw new ValidationError("all elements in models must be strings");
        }
        // Validate only one model is provided
        if (models.length > 1) {
            throw new ValidationError("Only one model is supported for text-to-speech processing at this time");
        }
        if (!prompt || typeof prompt !== "string" || prompt.trim() === "") {
            throw new ValidationError("prompt must be a non-empty string");
        }
        // Validate voice if provided
        if (voice && typeof voice !== "string") {
            throw new ValidationError("voice must be a string");
        }
        // Simple validation for model_specific_params
        if (model_specific_params !== undefined &&
            typeof model_specific_params !== "object") {
            throw new ValidationError("model_specific_params must be an object");
        }
        return this.makeRequest("/audio/tts", {
            models,
            prompt,
            voice,
            model_specific_params,
        });
    }
    /**
     * Converts speech to text using AI model.
     * @param {sttTypes} request - The request object containing:
     * - models: Array of model identifiers to use for speech-to-text (required) - e.g., ["gpt-4o-transcribe"]
     * - audio_file: Path to audio file or URL (required)
     * - model_specific_params: Additional parameters specific to the model (optional)
     * @returns {Promise<string>} A promise that resolves to the transcribed text
     * @throws {ValidationError} Will throw an error if required parameters are missing or invalid
     * @example
     * JavaScript (CommonJS) usage:
     * ```javascript
     * const client = require("alle-ai-sdk");
     * async function runSTT() {
     *   const alleai = new client.AlleAIClient({ apiKey: "your-apiKey" });
     *   const text = await alleai.audio.stt({
     *     models: ["gpt-4o-transcribe"],
     *     audio_file: "./audio.mp3",  // or "https://example.com/audio.mp3"
     *     model_specific_params: {
     *       // Optional model-specific parameters
     *     }
     *   });
     *   console.log(text);
     * }
     * runSTT();
     * ```
     * @example
     * TypeScript usage:
     * ```typescript
     * import { AlleAI } from "alle-ai-sdk";
     * async function runSTT() {
     *   const alleai = new AlleAIClient({ apiKey: "your-apiKey" });
     *   const text = await alleai.audio.stt({
     *     models: ["gpt-4o-transcribe"],
     *     audio_file: "./audio.mp3",  // or "https://example.com/audio.mp3"
     *     model_specific_params: {
     *       // Optional model-specific parameters
     *     }
     *   });
     *   console.log(text);
     * }
     * runSTT();
     * ```
     */
    async stt({ models, audio_file, model_specific_params = {}, }) {
        // Validate required parameters
        if (!models || !Array.isArray(models) || models.length === 0) {
            throw new ValidationError("models must be a non-empty array of strings");
        }
        if (!models.every((model) => typeof model === "string")) {
            throw new ValidationError("all elements in models must be strings");
        }
        // Validate only one model is provided
        if (models.length > 1) {
            throw new ValidationError("Only one model is supported for speech-to-text processing at this time");
        }
        if (!audio_file ||
            typeof audio_file !== "string" ||
            audio_file.trim() === "") {
            throw new ValidationError("audio_file must be a non-empty string");
        }
        // Simple validation for model_specific_params
        if (model_specific_params !== undefined &&
            typeof model_specific_params !== "object") {
            throw new ValidationError("model_specific_params must be an object");
        }
        try {
            // Process the audio file using the utility function
            const { buffer, filename } = await processFile(audio_file, "audio");
            // Create FormData instance
            const formData = new FormData();
            // Append each model individually
            models.forEach((model, index) => {
                formData.append(`models[${index}]`, model);
            });
            // Append the buffer directly with filename
            formData.append("audio_file", buffer, {
                filename: filename,
            });
            // If we have model specific params, append them
            if (Object.keys(model_specific_params).length > 0) {
                formData.append("model_specific_params", JSON.stringify(model_specific_params));
            }
            // Use makeFormDataRequest
            return await this.makeFormDataRequest("/audio/stt", formData);
        }
        catch (error) {
            throw new ValidationError(` ${error instanceof Error ? error.message : String(error)}`);
        }
    }
}

// Use require for form-data since it's a CommonJS module
require('form-data');
/**
 * Handles video-related operations, including generating videos from text
 * and editing existing videos.
 * @class AlleVideo
 * @example
 * JavaScript (CommonJS) usage:
 * ```javascript
 * const client = require("alle-ai-sdk");
 * async function runVideo() {
 *   const alleai = new client.AlleAIClient({ apiKey: "your-apiKey" });
 *   const video = await alleai.video.generate({
 *     models: ["nova-reel", "veo-2"],
 *     prompt: "Create a video about nature.",
 *     duration: 6,
 *     aspect_ratio: "16:9",
 *     fps: 24,
 *     dimension: "1280x720",
 *     resolution: "720p",
 *     seed: 8,
 *     model_specific_params: {
 *       // Optional model-specific parameters
 *     }
 *   });
 *   console.log(video);
 * }
 * runVideo();
 * ```
 * @example
 * TypeScript usage:
 * ```typescript
 * import { AlleAIClient } from "alle-ai-sdk";
 * async function runVideo() {
 *   const alleai = new AlleAIClient({ apiKey: "your-apiKey" });
 *   const video = await alleai.video.generate({
 *     models: ["nova-reel", "veo-2"],
 *     prompt: "Create a video about nature.",
 *     duration: 6,
 *     aspect_ratio: "16:9",
 *     fps: 24,
 *     dimension: "1280x720",
 *     resolution: "720p",
 *     seed: 8,
 *     model_specific_params: {
 *       // Optional model-specific parameters
 *     }
 *   });
 *   console.log(video);
 * }
 * runVideo();
 * ```
 */
class AlleVideo {
    /**
     * Creates an instance of AlleVideo.
     * @param {function} makeRequest - The function to make JSON API requests
     * @param {function} makeFormDataRequest - The function to make FormData API requests
     */
    constructor(makeRequest, makeFormDataRequest) {
        this.makeRequest = makeRequest;
        this.makeFormDataRequest = makeFormDataRequest;
    }
    /**
     * Generates a video from the provided text prompt using AI models.
     * @param {TextToVideoTypes} request - The request object containing:
     * - models: Array of model identifiers to use for generation (required) - e.g., ["nova-reel", "veo-2"]
     * - prompt: Text description of the desired video (required)
     * - duration: Duration of the video in seconds (optional, default: 6)
     * - loop: Whether to make the video loop (optional, default: false)
     * - aspect_ratio: Aspect ratio of the video (optional, default: "16:9")
     * - fps: Frames per second (optional, default: 24)
     * - dimension: Video dimensions (optional, e.g., "1280x720")
     * - resolution: Video resolution (optional, e.g., "720p")
     * - seed: Random seed for reproducibility (optional)
     * - model_specific_params: Additional parameters specific to the model (optional)
     * @returns {Promise<string>} A promise that resolves to the URL of the generated video
     * @throws {ValidationError} Will throw an error if required parameters are missing or invalid
     * @example
     * JavaScript (CommonJS) usage:
     * ```javascript
     * const client = require("alle-ai-sdk");
     * async function runVideo() {
     *   const alleai = new client.AlleAIClient({ apiKey: "your-apiKey" });
     *   const video = await alleai.video.generate({
     *     models: ["nova-reel", "veo-2"],
     *     prompt: "Create a video about nature.",
     *     duration: 6,
     *     aspect_ratio: "16:9",
     *     fps: 24,
     *     dimension: "1280x720",
     *     resolution: "720p",
     *     seed: 8
     *   });
     *   console.log(video);
     * }
     * runVideo();
     * ```
     * @example
     * TypeScript usage:
     * ```typescript
     * import { AlleAIClient } from "alle-ai-sdk";
     * async function runVideo() {
     *   const alleai = new AlleAIClient({ apiKey: "your-apiKey" });
     *   const video = await alleai.video.generate({
     *     models: ["nova-reel", "veo-2"],
     *     prompt: "Create a video about nature.",
     *     duration: 6,
     *     aspect_ratio: "16:9",
     *     fps: 24,
     *     dimension: "1280x720",
     *     resolution: "720p",
     *     seed: 8
     *   });
     *   console.log(video);
     * }
     * runVideo();
     * ```
     */
    async generate({ models, prompt, duration = 6, loop = false, aspect_ratio = "16:9", fps = 24, dimension, resolution, seed, model_specific_params = {}, }) {
        // Validate required parameters
        if (!models || !Array.isArray(models) || models.length === 0) {
            throw new ValidationError("models must be a non-empty array of strings");
        }
        if (!models.every((model) => typeof model === "string")) {
            throw new ValidationError("all elements in models must be strings");
        }
        if (!prompt || typeof prompt !== "string" || prompt.trim() === "") {
            throw new ValidationError("prompt must be a non-empty string");
        }
        // Validate optional parameters
        if (duration !== undefined) {
            if (typeof duration !== "number" || duration <= 0) {
                throw new ValidationError("duration must be a positive number");
            }
        }
        if (loop !== undefined && typeof loop !== "boolean") {
            throw new ValidationError("loop must be a boolean");
        }
        if (aspect_ratio !== undefined) {
            const [width, height] = aspect_ratio.split(":");
            if (!width || !height || isNaN(Number(width)) || isNaN(Number(height))) {
                throw new ValidationError("aspect_ratio must be in the format 'width:height' (e.g., '16:9')");
            }
        }
        if (fps !== undefined) {
            if (typeof fps !== "number" || fps <= 0) {
                throw new ValidationError("fps must be a positive number");
            }
        }
        if (dimension !== undefined) {
            const [width, height] = dimension.split("x");
            if (!width || !height || isNaN(Number(width)) || isNaN(Number(height))) {
                throw new ValidationError("dimension must be in the format 'widthxheight' (e.g., '1280x720')");
            }
        }
        if (seed !== undefined) {
            if (typeof seed !== "number" || !Number.isInteger(seed)) {
                throw new ValidationError("seed must be an integer");
            }
        }
        // Simple validation for model_specific_params
        if (model_specific_params !== undefined &&
            typeof model_specific_params !== "object") {
            throw new ValidationError("model_specific_params must be an object");
        }
        return this.makeRequest("/video/generate", {
            models,
            prompt,
            duration,
            loop,
            aspect_ratio,
            fps,
            dimension,
            resolution,
            seed,
            model_specific_params,
        });
    }
    /**
     * Edits a video based on the provided parameters using multiple AI models.
     * @param {VideoEdit} request - The request object containing:
     * - models: Array of model identifiers to use for editing
     * - prompt: Description of desired changes to the video
     * - videoUrl: Video input; a video URL link if from a URL, or a base64-encoded string if from a file
     * @returns {Promise<string>} A promise that resolves to the URL of the edited video
     * @throws {ValidationError} Will throw an error if required parameters are missing or invalid
     * @example
     * JavaScript (CommonJS) usage:
     * ```javascript
     * const client = require("alle-ai-sdk");
     * async function runVideoEdit() {
     *   const alleai = new client.AlleAIClient({ apiKey: "your-apiKey" });
     *   const editedVideo = await alleai.video.edit({
     *     models: ['video-model1'],
     *     prompt: 'Add a sunset scene at the beginning',
     *     videoUrl: 'https://example.com/video.mp4'
     *   });
     *   console.log(editedVideo);
     * }
     * runVideoEdit();
     * ```
     * @example
     * TypeScript usage:
     * ```typescript
     * import { AlleAIClient } from "alle-ai-sdk";
     * async function runVideoEdit() {
     *   const alleai = new AlleAIClient({ apiKey: "your-apiKey" });
     *   const editedVideo = await alleai.video.edit({
     *     models: ['video-model1'],
     *     prompt: 'Add a sunset scene at the beginning',
     *     videoUrl: 'https://example.com/video.mp4'
     *   });
     *   console.log(editedVideo);
     * }
     * runVideoEdit();
     * ```
     */
    // unavailable for now : uncomment when available
    // async edit({ models, prompt, videoUrl }: VideoEdit): Promise<any> {
    //   // Validate required parameters
    //   if (!models || !Array.isArray(models) || models.length === 0) {
    //     throw new ValidationError("models must be a non-empty array of strings");
    //   }
    //   if (!models.every((model) => typeof model === "string")) {
    //     throw new ValidationError("all elements in models must be strings");
    //   }
    //   if (!prompt || typeof prompt !== "string" || prompt.trim() === "") {
    //     throw new ValidationError("prompt must be a non-empty string");
    //   }
    //   if (!videoUrl || typeof videoUrl !== "string" || videoUrl.trim() === "") {
    //     throw new ValidationError("videoUrl must be a non-empty string");
    //   }
    //   return this.makeRequest("/video/edit", {
    //     models,
    //     prompt,
    //     videoUrl,
    //   });
    // }
    /**
     * Checks the status of a video generation or edit job.
     * @param {string} requestId - The ID of the video job to check (e.g., "alleai-F")
     * @returns {Promise<object>} A promise that resolves to the status information
     * @throws {ValidationError} Will throw an error if request_id is missing or invalid
     * @example
     * JavaScript (CommonJS) usage:
     * ```javascript
     * const client = require("alle-ai-sdk");
     * async function checkVideoStatus() {
     *   const alleai = new client.AlleAIClient({ apiKey: "your-apiKey" });
     *   const status = await alleai.video.get_video_status("alleai-F");
     *   console.log(status);
     * }
     * checkVideoStatus();
     * ```
     * @example
     * TypeScript usage:
     * ```typescript
     * import { AlleAIClient } from "alle-ai-sdk";
     * async function checkVideoStatus() {
     *   const alleai = new AlleAIClient({ apiKey: "your-apiKey" });
     *   const status = await alleai.video.get_video_status("alleai-F");
     *   console.log(status);
     * }
     * checkVideoStatus();
     * ```
     */
    async get_video_status(requestId) {
        // Validate request_id
        if (!requestId ||
            typeof requestId !== "string" ||
            requestId.trim() === "") {
            throw new ValidationError("request_id must be a non-empty string");
        }
        // return this.makeRequest("/video/status", {
        //   requestId: requestId
        // });
        return {
            status: "not available",
            message: "This feature is not available yet",
        };
    }
}

// Use require for CommonJS modules
require('form-data');
const fetch = require('node-fetch');
/**
 * Main class for interacting with the Alle AI API
 * @class AlleAIClient
 * @example
 * ```typescript
 * const alle = new AlleAIClient({
 *   apiKey: 'your-api-key'
 * });
 * ```
 */
class AlleAIClient {
    /**
     * Creates an instance of AlleAI.
     * @param {AlleAIConfig} config - The configuration object
     * @throws {ValidationError} Will throw an error if apiKey is not provided
     */
    constructor(config) {
        if (!config.apiKey) {
            throw new ValidationError("API key is required", "MISSING_API_KEY");
        }
        this.apiKey = config.apiKey;
        this.baseUrl = config.baseUrl || "https://api.alle-ai.com/api/v1";
        const handleErrorResponse = async (response) => {
            var _a;
            const status = response.status;
            let errorMessage = `Request failed with status: ${status}`;
            try {
                const errorBody = await response.text();
                // Check if the entire response is HTML
                if (errorBody.includes("<!DOCTYPE html>") ||
                    errorBody.includes("<html")) {
                    errorMessage =
                        "Server responded with unknown format. Please try again later.";
                }
                else {
                    // Try to parse as JSON if not HTML
                    try {
                        const errorJson = JSON.parse(errorBody);
                        // Check if JSON response has HTML in details.raw
                        if (((_a = errorJson.details) === null || _a === void 0 ? void 0 : _a.raw) &&
                            (errorJson.details.raw.includes("<!DOCTYPE html>") ||
                                errorJson.details.raw.includes("<html"))) {
                            errorMessage =
                                "Server responded with unknown format. Please try again later.";
                        }
                        else if (errorJson.message) {
                            errorMessage = errorJson.message;
                        }
                        else if (errorJson.error) {
                            errorMessage =
                                typeof errorJson.error === "string"
                                    ? errorJson.error
                                    : JSON.stringify(errorJson.error);
                        }
                    }
                    catch (parseError) {
                        // If not valid JSON and not HTML, use generic message
                        errorMessage =
                            "Server responded with unknown format. Please try again later.";
                    }
                }
            }
            catch (textError) {
                // In case response.text() fails
                errorMessage =
                    "Server responded with unknown format. Please try again later.";
            }
            // Map HTTP status codes to specific error types with clean error structure
            const errorResponse = {
                message: errorMessage,
                status: status,
            };
            switch (status) {
                case 400:
                    throw new InvalidRequestError(errorMessage, "INVALID_REQUEST", errorResponse);
                case 401:
                    throw new AuthenticationError(errorMessage, "AUTH_ERROR", errorResponse);
                case 403:
                    throw new AuthenticationError(errorMessage, "PERMISSION_DENIED", errorResponse);
                case 404:
                    throw new APIError(errorMessage, "RESOURCE_NOT_FOUND", status, errorResponse);
                case 429:
                    throw new RateLimitError(errorMessage, "RATE_LIMIT", errorResponse);
                case 500:
                case 502:
                case 503:
                case 504:
                    throw new ServiceUnavailableError(errorMessage, "SERVICE_ERROR", errorResponse);
                default:
                    throw new APIError(errorMessage, `API_ERROR_${status}`, status, errorResponse);
            }
        };
        // HTTP request method for JSON requests
        const makeRequest = async (endpoint, body) => {
            try {
                const response = await fetch(`${this.baseUrl}${endpoint}`, {
                    method: "POST",
                    headers: {
                        "X-API-KEY": this.apiKey,
                        Authorization: `Bearer ${this.apiKey}`,
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify(body),
                });
                if (!response.ok) {
                    await handleErrorResponse(response);
                }
                try {
                    const data = await response.json();
                    return data;
                }
                catch (parseError) {
                    throw new APIError("Server returned invalid JSON response", "INVALID_RESPONSE", response.status, { message: "Invalid JSON response" });
                }
            }
            catch (error) {
                if (error instanceof AlleAIError) {
                    throw error;
                }
                if (error instanceof TypeError && error.message.includes("fetch")) {
                    throw new ConnectionError("Could not connect to the API. Please check your internet connection.", "CONNECTION_ERROR", { originalError: error.message });
                }
                const errorMessage = error instanceof Error ? error.message : String(error);
                throw new APIError(`An unexpected error occurred: ${errorMessage}`, "UNEXPECTED_ERROR", undefined, { originalError: errorMessage });
            }
        };
        // HTTP request method for FormData requests
        const makeFormDataRequest = async (endpoint, formData) => {
            try {
                const response = await fetch(`${this.baseUrl}${endpoint}`, {
                    method: "POST",
                    headers: {
                        "X-API-KEY": this.apiKey,
                        Authorization: `Bearer ${this.apiKey}`,
                        ...formData.getHeaders(),
                    },
                    body: formData,
                });
                if (!response.ok) {
                    await handleErrorResponse(response);
                }
                try {
                    const data = await response.json();
                    return data;
                }
                catch (parseError) {
                    throw new APIError("Server returned invalid JSON response", "INVALID_RESPONSE", response.status, { message: "Invalid JSON response" });
                }
            }
            catch (error) {
                if (error instanceof AlleAIError) {
                    throw error;
                }
                if (error instanceof TypeError && error.message.includes("fetch")) {
                    throw new ConnectionError("Could not connect to the API. Please check your internet connection.", "CONNECTION_ERROR", { originalError: error.message });
                }
                const errorMessage = error instanceof Error ? error.message : String(error);
                throw new APIError(`An unexpected error occurred: ${errorMessage}`, "UNEXPECTED_ERROR", undefined, { originalError: errorMessage });
            }
        };
        //module instances with both request methods
        this.chat = new AlleChat(makeRequest);
        this.image = new AlleImage(makeRequest, makeFormDataRequest);
        this.audio = new AlleAudio(makeRequest, makeFormDataRequest);
        this.video = new AlleVideo(makeRequest, makeFormDataRequest);
    }
}

exports.AlleAIClient = AlleAIClient;
